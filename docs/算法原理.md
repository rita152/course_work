# Portfolio Selection 算法原理与实现步骤

**投资组合优化的线性规划方法**

---

## 目录

1. [问题背景](#1-问题背景)
2. [数学建模](#2-数学建模)
3. [线性规划转化](#3-线性规划转化)
4. [求解算法](#4-求解算法)
5. [参数化求解](#5-参数化求解)
6. [实现步骤](#6-实现步骤)
7. [算法复杂度分析](#7-算法复杂度分析)

---

## 1. 问题背景

### 1.1 投资组合选择问题

**核心问题**：给定n个投资标的，如何分配资金以实现风险和收益的最优平衡？

**输入**：
- n个资产的历史收益率数据：$R_j(t)$，其中 $j=1,...,n$ 为资产索引，$t=1,...,T$ 为时间索引
- 风险厌恶参数：$\mu > 0$

**输出**：
- 最优资产配置权重：$x_j \geq 0$，满足 $\sum_j x_j = 1$

**目标**：
- 在控制风险的前提下最大化收益
- 或在保证收益的前提下最小化风险

### 1.2 经典理论基础

1. **Markowitz均值-方差模型**（1952）
   - 使用方差度量风险
   - 导致二次规划问题
   - 计算复杂度较高

2. **MAD模型**（Konno & Yamazaki, 1991）
   - 使用均值绝对偏差（Mean Absolute Deviation）度量风险
   - 可转化为线性规划问题
   - 计算效率显著提升

**本项目采用MAD模型的优势**：
- ✅ 保持问题的线性性质
- ✅ 求解效率高（秒级）
- ✅ 对极端值更鲁棒
- ✅ 易于理解和实现

---

## 2. 数学建模

### 2.1 符号定义

| 符号 | 含义 | 说明 |
|------|------|------|
| $n$ | 资产数量 | 本项目：9个ETF |
| $T$ | 时间期数 | 本项目：36个月 |
| $R_j(t)$ | 资产j在时期t的收益率 | 历史数据 |
| $r_j$ | 资产j的期望收益 | $r_j = \frac{1}{T}\sum_{t=1}^T R_j(t)$ |
| $x_j$ | 资产j的配置比例 | **决策变量** |
| $\mu$ | 风险厌恶参数 | 权衡风险和收益 |

### 2.2 投资组合收益

给定配置权重 $\mathbf{x} = (x_1, ..., x_n)^T$，投资组合在时期t的收益为：

$$R_p(t) = \sum_{j=1}^n x_j R_j(t)$$

**期望收益**（回报）：

$$\mathbb{E}[R_p] = \sum_{j=1}^n x_j \mathbb{E}[R_j] = \sum_{j=1}^n x_j r_j$$

### 2.3 风险度量：MAD

**定义**：均值绝对偏差（Mean Absolute Deviation）

$$\text{Risk} = \mathbb{E}|R_p - \mathbb{E}[R_p]|$$

**展开形式**：

$$\text{Risk} = \mathbb{E}\left|\sum_{j=1}^n x_j(R_j - r_j)\right|$$

**离散化估计**（使用历史数据）：

$$\text{Risk} = \frac{1}{T}\sum_{t=1}^T \left|\sum_{j=1}^n x_j(R_j(t) - r_j)\right|$$

**关键洞察**：
- 方差度量：$\mathbb{E}[(R_p - \mathbb{E}[R_p])^2]$ → 导致二次规划
- MAD度量：$\mathbb{E}|R_p - \mathbb{E}[R_p]|$ → 可转化为线性规划

### 2.4 多目标优化

投资组合选择本质上是一个**多目标优化问题**：

$$
\begin{cases}
\max & \text{回报} = \sum_{j=1}^n x_j r_j \\
\min & \text{风险} = \frac{1}{T}\sum_{t=1}^T \left|\sum_{j=1}^n x_j(R_j(t) - r_j)\right|
\end{cases}
$$

**线性加权法**：将两个目标合并为单一目标

$$\max \quad \mu \cdot \text{回报} - \text{风险}$$

参数$\mu$的经济含义：
- $\mu$ 很大：优先追求高回报，容忍高风险（激进型投资者）
- $\mu$ 很小：优先控制风险，接受低回报（保守型投资者）
- $\mu \approx 1$：风险和回报同等重要（平衡型投资者）

---

## 3. 线性规划转化

### 3.1 初始优化模型

$$
\begin{aligned}
\max \quad & \mu \sum_{j=1}^n x_j r_j - \frac{1}{T}\sum_{t=1}^T \left|\sum_{j=1}^n x_j(R_j(t) - r_j)\right| \\
\text{s.t.} \quad & \sum_{j=1}^n x_j = 1 \\
& x_j \geq 0, \quad j = 1,...,n
\end{aligned}
$$

**问题**：目标函数中包含绝对值，不是线性的！

### 3.2 绝对值的线性化技巧

**核心思想**：引入辅助变量代替绝对值

令 $y_t$ 表示第t期的绝对偏差：

$$y_t = \left|\sum_{j=1}^n x_j(R_j(t) - r_j)\right|$$

**等价转化**：

$$y_t \geq \left|\sum_{j=1}^n x_j(R_j(t) - r_j)\right|$$

可以用两个不等式表示：

$$
\begin{cases}
y_t \geq \sum_{j=1}^n x_j(R_j(t) - r_j) \\
y_t \geq -\sum_{j=1}^n x_j(R_j(t) - r_j)
\end{cases}
$$

即：

$$-y_t \leq \sum_{j=1}^n x_j(R_j(t) - r_j) \leq y_t$$

**为什么等价**？
- 在最优解处，至少有一个不等式取等号
- 如果两个都是严格不等式，可以减小$y_t$，从而增大目标函数值
- 因此最优时 $y_t = \left|\sum_j x_j(R_j(t) - r_j)\right|$

### 3.3 标准线性规划形式

引入偏差变量 $D_{tj} = R_j(t) - r_j$（常数），最终的LP模型为：

$$
\begin{aligned}
\max \quad & \mu \sum_{j=1}^n x_j r_j - \frac{1}{T}\sum_{t=1}^T y_t \\
\text{s.t.} \quad & -y_t \leq \sum_{j=1}^n x_j D_{tj} \leq y_t, \quad t = 1,...,T \\
& \sum_{j=1}^n x_j = 1 \\
& x_j \geq 0, \quad j = 1,...,n \\
& y_t \geq 0, \quad t = 1,...,T
\end{aligned}
$$

**问题规模**：
- 决策变量数：$n + T$ （9个$x_j$ + 36个$y_t$ = 45个变量）
- 约束条件数：$2T + 1$ （72个绝对值约束 + 1个预算约束 = 73个约束）

---

## 4. 求解算法

### 4.1 单纯形法（Simplex Method）

**基本原理**：
1. 从一个基本可行解开始
2. 沿着可行域的边界移动
3. 每次迭代改进目标函数值
4. 直到找到最优解（所有约化成本非正）

**标准形式**：需要将不等式转化为等式

引入松弛变量 $w_t^+$ 和 $w_t^-$：

$$
\begin{aligned}
-y_t + \sum_{j=1}^n x_j D_{tj} + w_t^+ &= 0 \\
-y_t - \sum_{j=1}^n x_j D_{tj} + w_t^- &= 0
\end{aligned}
$$

**完整标准形式**：

$$
\begin{aligned}
\max \quad & \mu \sum_{j=1}^n x_j r_j - \frac{1}{T}\sum_{t=1}^T y_t \\
\text{s.t.} \quad & -y_t + \sum_{j=1}^n x_j D_{tj} + w_t^+ = 0, \quad t = 1,...,T \\
& -y_t - \sum_{j=1}^n x_j D_{tj} + w_t^- = 0, \quad t = 1,...,T \\
& \sum_{j=1}^n x_j = 1 \\
& x_j, y_t, w_t^+, w_t^- \geq 0
\end{aligned}
$$

**变量总数**：$3T + n$ = 108 + 9 = 117个
**约束总数**：$2T + 1$ = 72 + 1 = 73个
**基本变量数**：73个
**非基本变量数**：44个

### 4.2 PuLP建模框架

**PuLP优势**：
- 自动处理标准形式转化
- 提供直观的建模语法
- 自动调用求解器（CBC）
- 无需手动处理松弛变量

**代码示例**：

```python
from pulp import *

# 创建问题
prob = LpProblem("Portfolio_Optimization", LpMaximize)

# 定义决策变量
x = [LpVariable(f"x_{j}", lowBound=0) for j in range(n)]
y = [LpVariable(f"y_{t}", lowBound=0) for t in range(T)]

# 目标函数
prob += mu * lpSum([x[j] * r[j] for j in range(n)]) - (1.0/T) * lpSum(y)

# 约束条件
prob += lpSum(x) == 1  # 预算约束

for t in range(T):
    deviation = lpSum([x[j] * D[t,j] for j in range(n)])
    prob += deviation <= y[t]   # 上界
    prob += deviation >= -y[t]  # 下界

# 求解
prob.solve(PULP_CBC_CMD(msg=0))
```

### 4.3 CBC求解器

**COIN-OR CBC** (COIN-OR Branch and Cut)：
- 开源线性规划求解器
- 基于单纯形法和内点法
- 支持大规模问题
- PuLP自动集成

**求解流程**：
1. 预处理（消除冗余约束、固定变量）
2. 初始基可行解（使用人工变量法）
3. 单纯形迭代（选择入基变量和出基变量）
4. 最优性检验（检查所有约化成本）
5. 输出最优解

---

## 5. 参数化求解

### 5.1 为什么需要参数化？

对于不同风险偏好的投资者，最优投资组合不同：
- 保守型：$\mu$ 小，优先控制风险
- 激进型：$\mu$ 大，优先追求收益
- 平衡型：$\mu$ 中等，兼顾两者

**有效前沿**：所有帕累托最优的风险-收益组合构成的曲线

### 5.2 参数单纯形法原理

**思想**：
- 对于某个$\mu_0$，求得最优解和最优字典
- 当$\mu$连续变化时，字典结构可能改变
- 追踪字典变化的临界点，系统地生成所有最优解

**简化方法**（本项目采用）：
- 选择一系列离散的$\mu$值：$\mu_1, \mu_2, ..., \mu_K$
- 对每个$\mu_k$独立求解LP问题
- 生成K个最优投资组合
- 绘制有效前沿

**$\mu$值选择策略**：

使用**对数刻度**覆盖广泛范围：

```python
mu_values = np.logspace(-1, 1.5, 30)
# 生成：[0.1, 0.12, 0.15, ..., 1.0, ..., 10, ..., 31.6]
```

**为什么用对数刻度？**
- 低$\mu$区域：解变化快，需要密集采样
- 高$\mu$区域：解趋于稳定，可以稀疏采样
- 对数刻度在整个范围内保持相对密度一致

### 5.3 有效前沿的性质

**定义**：风险-收益空间中的帕累托前沿

**性质**：
1. **单调性**：沿前沿移动，风险增加则收益也增加
2. **凹性**：前沿是凹曲线（向右上方凸）
3. **支配性**：前沿上的点支配其左上方的所有点

**数学表达**：

对于前沿上的任意两点$(r_1, \sigma_1)$和$(r_2, \sigma_2)$，如果$\sigma_1 < \sigma_2$，则$r_1 < r_2$。

---

## 6. 实现步骤

### 6.1 数据准备阶段

#### 步骤1：数据获取

```python
import yfinance as yf
import time

tickers = ['SHY', 'XLB', 'XLE', 'XLF', 'XLI', 'XLK', 'XLP', 'XLU', 'XLV']
price_data = {}

for ticker in tickers:
    data = yf.download(ticker, start='2022-11-01', end='2025-10-31')
    price_data[ticker] = data['Adj Close']
    time.sleep(2.5)  # 限流保护
```

**关键点**：
- 使用调整后收盘价（Adjusted Close）考虑分红和拆股
- 添加延时避免被Yahoo Finance限流
- 处理缺失值（删除或插值）

#### 步骤2：计算收益率

```python
# 重采样到月度（取每月最后一个交易日）
monthly_prices = price_data.resample('ME').last()

# 计算简单收益率
returns = monthly_prices / monthly_prices.shift(1)
returns = returns.dropna()  # 删除第一行
```

**收益率公式**：

$$R_j(t) = \frac{P_j(t)}{P_j(t-1)}$$

其中$P_j(t)$为资产j在时期t的价格。

#### 步骤3：计算统计量

```python
# 期望收益（历史均值）
r = returns.mean(axis=0)  # shape: (n,)

# 偏差矩阵
D = returns - r  # shape: (T, n)
```

**数据结构**：

| 数据 | 维度 | 说明 |
|------|------|------|
| `returns` | (T, n) | 收益率矩阵 |
| `r` | (n,) | 期望收益向量 |
| `D` | (T, n) | 偏差矩阵 |

### 6.2 模型构建阶段

#### 步骤4：创建LP问题

```python
from pulp import *

prob = LpProblem("Portfolio_Optimization", LpMaximize)
```

#### 步骤5：定义决策变量

```python
# 资产配置权重
x = [LpVariable(f"x_{j}", lowBound=0) for j in range(n)]

# 绝对偏差
y = [LpVariable(f"y_{t}", lowBound=0) for t in range(T)]
```

**变量约束**：
- $x_j \geq 0$：不允许卖空
- $y_t \geq 0$：偏差为非负

#### 步骤6：定义目标函数

```python
# 回报部分
reward = lpSum([x[j] * r[j] for j in range(n)])

# 风险部分
risk = (1.0 / T) * lpSum(y)

# 目标函数
prob += mu * reward - risk
```

#### 步骤7：添加约束条件

```python
# 预算约束：权重之和为1
prob += lpSum(x) == 1

# 绝对值约束：对每个时期t
for t in range(T):
    deviation_t = lpSum([x[j] * D[t, j] for j in range(n)])
    prob += deviation_t <= y[t]   # 上界约束
    prob += deviation_t >= -y[t]  # 下界约束
```

**约束解释**：

$$
\begin{aligned}
\sum_{j=1}^n x_j D_{tj} &\leq y_t \\
\sum_{j=1}^n x_j D_{tj} &\geq -y_t
\end{aligned}
\quad \Rightarrow \quad
y_t \geq \left|\sum_{j=1}^n x_j D_{tj}\right|
$$

### 6.3 求解阶段

#### 步骤8：调用求解器

```python
# 求解（不显示输出）
prob.solve(PULP_CBC_CMD(msg=0))

# 检查求解状态
if prob.status == 1:  # Optimal
    print("求解成功！")
else:
    print(f"求解失败，状态码：{prob.status}")
```

**求解状态码**：
- 1: Optimal（最优）
- 0: Not Solved（未求解）
- -1: Infeasible（不可行）
- -2: Unbounded（无界）

#### 步骤9：提取最优解

```python
# 提取最优权重
optimal_weights = np.array([x[j].varValue for j in range(n)])

# 提取最优偏差
optimal_y = np.array([y[t].varValue for t in range(T)])

# 计算最优目标函数值
optimal_value = prob.objective.value()

# 计算最优收益和风险
optimal_return = np.dot(optimal_weights, r)
optimal_risk = np.mean(optimal_y)
```

### 6.4 参数化求解阶段

#### 步骤10：遍历$\mu$值

```python
# 生成μ值序列
mu_values = np.logspace(-1, 1.5, 30)

results = []
for mu in mu_values:
    # 构建并求解模型
    prob, x_vars, y_vars = build_model(mu)
    prob.solve(PULP_CBC_CMD(msg=0))
    
    # 提取结果
    weights = [x_vars[j].varValue for j in range(n)]
    expected_return = np.dot(weights, r)
    risk = np.mean([y_vars[t].varValue for t in range(T)])
    
    results.append({
        'mu': mu,
        'weights': weights,
        'return': expected_return,
        'risk': risk
    })
```

**计算效率**：
- 单个问题：< 0.1秒
- 30个问题总计：< 3秒
- 并行化潜力：可进一步加速

### 6.5 分析阶段

#### 步骤11：绘制有效前沿

```python
import matplotlib.pyplot as plt

risks = [r['risk'] for r in results]
returns = [r['return'] for r in results]

plt.plot(risks, returns, 'b-o', label='Efficient Frontier')
plt.xlabel('Risk (MAD)')
plt.ylabel('Expected Return')
plt.title('Portfolio Efficient Frontier')
plt.legend()
plt.grid(True)
plt.show()
```

#### 步骤12：策略对比

**基准策略1：等权重**

$$x_j = \frac{1}{n}, \quad \forall j$$

**基准策略2：单一最优资产**

$$x_j = \begin{cases} 1, & j = \arg\max_i r_i \\ 0, & \text{otherwise} \end{cases}$$

**基准策略3：最小风险**

求解$\mu = 0$时的LP问题。

**性能指标：夏普比率**

$$\text{Sharpe Ratio} = \frac{\text{收益} - \text{无风险利率}}{\text{风险}}$$

更高的夏普比率表示更好的风险调整收益。

---

## 7. 算法复杂度分析

### 7.1 时间复杂度

**单纯形法理论复杂度**：
- 最坏情况：$O(2^m)$，其中m为约束数（指数级）
- 平均情况：$O(m^2 n)$ 到 $O(m^3)$（多项式级）
- 实践中：通常在多项式时间内求解

**本问题的复杂度**：
- $m = 2T + 1 = 73$ （约束数）
- $n_{var} = n + T = 45$ （变量数）
- 预期时间：$O(73^2 \times 45) \approx O(10^5)$ 次运算

**实测性能**：
- 单次求解：< 0.1秒
- 30次参数化求解：< 3秒

### 7.2 空间复杂度

**存储需求**：

1. **约束矩阵**：$m \times n_{var} = 73 \times 45 \approx 3,285$ 个元素
2. **基矩阵**：$m \times m = 73 \times 73 \approx 5,329$ 个元素
3. **中间结果**：$O(m + n_{var})$

**总空间复杂度**：$O(m^2 + mn_{var}) = O(73^2) \approx 5$KB

非常轻量，现代计算机完全无压力。

### 7.3 数值稳定性

**潜在问题**：
- 系数矩阵的条件数可能较大
- 收益率和偏差的数量级差异

**解决方案**：
1. 数据归一化（如果需要）
2. 使用修正单纯形法
3. CBC求解器内置数值稳定技术

### 7.4 可扩展性分析

**问题规模扩展**：

| 资产数(n) | 时期数(T) | 变量数 | 约束数 | 预期时间 |
|-----------|-----------|--------|--------|----------|
| 9 | 36 | 45 | 73 | < 0.1s |
| 50 | 60 | 110 | 121 | < 0.5s |
| 100 | 120 | 220 | 241 | < 2s |
| 500 | 240 | 740 | 481 | < 30s |

**结论**：
- 对于典型的投资组合问题（n < 100, T < 200），求解时间在秒级
- 可以处理包含数百个资产的大规模问题

---



## 8. 与其他方法的对比

### 8.1 方差模型 vs MAD模型

| 特征 | 方差模型 | MAD模型（本项目） |
|------|----------|------------------|
| 风险度量 | $\mathbb{E}[(R-\bar{R})^2]$ | $\mathbb{E}|R-\bar{R}|$ |
| 问题类型 | 二次规划（QP） | 线性规划（LP） |
| 求解算法 | 内点法、主动集法 | 单纯形法 |
| 计算复杂度 | $O(n^3)$ | $O(n^2 T)$ |
| 求解时间（n=9,T=36） | 约1秒 | < 0.1秒 |
| 对极端值敏感性 | 高（平方放大） | 低（线性） |

**结论**：MAD模型在保持合理风险度量的同时，显著提升了求解效率。

---